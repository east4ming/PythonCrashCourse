# 文件和异常

## 从文件中读取数据

### 读取整个文件

> 具体见`b_file_reader.py`

- `open()` 返回一个表示文件的对象
- `with` 在不需要访问文件后将其关闭, 这样就无需调用 `close()`
- `file_object.read()` 读取打开文件的全部内容.

### 文件路径

> 注意:
> windows系统有时可以正确解读文件路径中的斜杠'/'. 如果是windows系统, 且结果不符合预期, 确保在文件路径中使用反斜杠'\'.
> 为了确保万无一失, 应以原始字符串的方式指定路径, 及在开头的单引号前加上`r`

### 逐行读取

> 见`b_file_reader_2.py`

执行后发现有空白行, 为什么?
在该文件中, 每行的末尾都有一个看不见的换行符(如: '/n'), 而print语句也会加上一个换行符, 因此每行末尾有**2个换行符**: 一个来自文件, 一个来自print语句. 要消除多余的空白行, 可使用`rstrip()`

### 创建一个包含文件各行内容的列表

> 见`b_file_reader_2.1.py`

`file_object.readlines()` 从文件中读取每一行, 并将其存储在一个列表中.

### 使用文件的内容

> 见`b_pi_string.py`

`string.strip()` 删除左右两边的空格.
读取文本文件时, 将其文本都解读为**字符串**. 如果要转换为数字, 需要使用`int()`或`float()`进行转换.

### 包含一百万位的大型文件

> 见`b_pi_string.1.py`

### 圆周率值中包含你的生日吗

> 见`b_pi_birthday.py`

## 写入文件

### 10.2.1 写入空文件

> 见`b_write_message.py`

第二个实参(`w`), 以*写入模式*打开文件. 模式有:

- r: 读取模式(默认模式)
- w: 写入模式. **如果文件已存在, 会清空该文件**
- a: 附加模式
- r+:

如果写入的文件不存在, `open()`将自动创建.

> python只能将**字符串**写入文本文件. 
> 要将数值写入文本文件, 必须先使用函数`str()`将其转换为字符串格式.

### 写入多行

函数`write()`不会在文本末尾添加换行符号, 需要手动添加换行符号.

> 见`b_write_messages.py`

### 附加到文件

如果要给文件添加内容, 而不是覆盖原有内容, 可以*附加模式*打开文件. 
使用该模式, python不会在返回文件对象前情况前清空文件, 写入的文件的行都添加到文件末尾.
如果文件不存在, 会创建一个空文件.

> 见`b_write_messages.1.py`

## 异常

python使用被称为*异常*的特殊对象来管理程序执行期间发生的错误.
每当发生错误时, 都会创建一个异常对象.
如果编写了处理该异常的代码, 程序会继续运行.
如果未对异常进行处理, 程序将停止, 并显示一个traceback, 其中包含有关异常的报告.

异常使用`try - except`代码块处理.

### 处理 ZeroDivisionError 异常

### 使用 try - except 代码块

> 见`b_division.py`

### 使用异常避免崩溃

发生错误时, 如果程序还有工作没有完成, 妥善处理错误尤其重要.

> 见`b_division.1.py`

`try - except - else` 代码块工作原理如下:
Python尝试执行`try`代码块中的代码; 只有可能引发异常的代码才需要放在try语句中.
有时候, 有一些仅在try代码块成功执行时才需要运行的代码; 这些代码应该放在else代码块中.
except 代码块告诉python, 如果它尝试运行try代码块中的代码时引发了执行的异常, 该怎么办.

通过预测可能发生错误的代码, 可编写健壮的程序, 他们即便面临无效数据或缺少资源, 也能继续运行, 从而能够抵御无意的用户错误和恶意的攻击.

### 处理 FileNotFoundError 异常

> 见`b_alice.py`

### 分析文本

很多经典文学作品都是以简单文本文件的方式提供的, 因为他们不受版权限制.

> 可以在项目 [Gutenberg](http://gutenberg.org/)

使用 `split()`来拆分单词.

> 具体见`b_alice_words.py`

### 使用多个文件

> 见`b_word_count`

### 失败时一声不吭

并非每次捕获到异常时都需要告诉用户, 有时候需要在程序发生异常时一声不吭, 就像什么都没有发生一样继续运行.
则要在except 块中什么都不做.

```python
try:
    ...
except expression as identifier:
    pass
else:
    ...
```

### 决定报告哪些错误

如果用户知道要分析哪些文件, 他们可能希望在有文件没有分析时出现一条消息, 将其中的原因告诉他们.
如果用户只想看到结果, 而并不知道要分析哪些文件, 可能就无需在有些文件不存在时告诉他们.

编写的很好且经过详尽测试的代码不容易出现内部错误, 如语法错误或逻辑错误,
但只压迫程序依赖于外部因素, 如**用户输入/存在指定的文件/有网络连接**, 就有可能出现异常.

## 存储数据

使用 json 来存储数据. 还可以在Python程序甚至其他程序之间分享数据. 

### 使用 json.dump() 和 json.load()

json.dump() 接受两个实参: 要存储的数据以及可用于存储数据的文件对象.

> 见`b_number_writer.py` 和 `b_number_reader.py`

### 保存和读取用户生成的数据

> 见`b_remember_me.py`

### 重构

你经常会遇到这样的情况: 代码能够正确地运行, 但可做进一步的改进 -- 将代码划分为一系列完成具体工作的函数. 这样的过程称为*重构*.
重构让代码更清晰, 更容易扩展.

> 重构`b_remember_me.py` 为 `b_remember_me.1.py`

新增函数 `get_stored_username()`, 如果存储了用户名, 就返回它; 如果文件不存在, 就返回 None.
这是一种简单的做法, 函数要么返回预期的值, 要么返回None; 这让我们能够使用函数的返回值做简单测试.

新增函数 `get_new_username()`, 这个函数只负责获取并存储新用户的用户名.

新增函数 `greet_user()`, 它打印一条合适的消息: 要么欢迎老用户, 要么问候新用户. 为此, 它首先调用`get_stored_username()`. 再在必要的时候调用 `get_new_username()`.


