# 测试代码

编写函数或类时, 可以为其编写测试.
通过测试, 可确定代码面对各种输入都能够按照要求那样工作. 
在程序中添加新代码时, 你也可以对其进行测试, 确认它们不会破坏程序既有的行为.
程序员都会犯错, 因此每个程序员都必须经常测试其代码, 在用户发现问题前找出他们.

## 测试函数

### 单元测试和测试用例

模块 `unittest` 提供了代码测试工具. 
*单元测试*用于合适函数的某个方面没有问题;
*测试用例*是一组单元测试, 这些单元测试一起核实函数在各种情形下的行为都符合要求.
良好的测试用例考虑到了函数可能收到的各种输入, 包含针对所有这些情形的测试.
*全覆盖式测试*用例包含一整套单元测试, 涵盖了各种可能的函数使用方式.

### 可通过的测试

> 见`b_test_name_function.py`

我们创建了一个名为`NamesTestCase`的类, 用于包含一系列针对`get_formatted_name()`的单元测试. 命名最好与测试的函数相关, 并包含字样Test. 这个类必须集成`unittest.TestCase`类.
当我们运行该py文件时, 所有**以*test_*打头的方法**都将自动运行. 
*断言*方法: `assertEqual()`, 用来合适得到的结果是否与期望的一致. 
代码行`unittest.main()`让Python运行这个文件中的测试.

### 不能通过的测试

测试结果说明:

- 第一行输出一个字母 E, 指出测试用例中有一个单元测试导致了错误.
- 接下来会看到出错的位置
- 之后, 会看到 Traceback
- 再之后, 看到单元测试的运行结果.

### 测试未通过时怎么办

测试未通过时, 不要修改测试, 而应修复导致测试不能通过的代码.

### 添加新测试

> 见`b_test_name_function.py`

## 测试类

编写针对**类**的测试.

### 各种断言方法

在`unittest.TestCase`类中提供了很多断言方法.


| 方法 | 用途 |
| ---- | ---- |
| assertEqual(a, b) | 核实a == b |
| assertNotEqual(a, b) | 核实a != b |
| assertTrue(x) | 核实x为True |
| assertFalse(x) | 核实x为False |
| assertIn(item, list) | 核实item在list中 |
| assertNotIn(item, list) | 核实item不在list中 |

### 一个要测试的类

> 见`b_survey`

### 测试 AnonymousSurvey 类

> 见`b_survey`

上述的测试效果还行, 但是测试有些重复的地方. 下面使用 unittest 的另一项功能来提高效率.
### 方法 setUp()

在前面的 test_survey.py 中, 我们在每个测试方法中都创建了一个 AnonymousSurvey实例, 并在每个方法中都创建了答案.
`unittest.TestCase`类包含方法`setUp()`, 让我们只需创建这些对象一次, 在运行各个以`test_`打头的方法. 
这样, 在你编写的每个测试方法中都可使用方法`setUp()`中创建的对象了.

> 见`b_survey`

方法`setUp()`做了两件事情: 创建一个调查对象; 创建一个答案列表. 存储在**测试类的属性中**, 因此可以在任何地方使用.

测试自己的类时:
可在`setUp()`方法中创建一系列实例并设置他们的属性, 再在测试方法中直接使用这些实例.

> 注意:
> 运行测试用例时, 没完成一个单元测试, Python都打印一个字符:
>
> - 通过: 一个句点`.`
> - 错误: `E`
> - 断言失败: `F`
>
> 如果测试用例包含很多单元测试, 需要运行很长时间, 就可以通过观察这些结果来获悉有多少个测试通过了.

## 小结

- 多开展测试来熟悉代码测试过程
- 对于自己的代码, 针对其重要行为编写测试
- 项目早期, 不要试图编写全覆盖的测试用例
